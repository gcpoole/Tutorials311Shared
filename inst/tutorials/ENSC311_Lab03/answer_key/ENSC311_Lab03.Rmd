---
title: "ENSC311 Lab 03: A roll of the dice"
tutorial:
  id: "ENSC311_Lab03"
output: 
  learnr::tutorial:
    progressive: true
runtime: shiny_prerendered
description: "An R learning lab exploring probablity distributions associated with rolling dice.  In this lab, you will build and demonstrate proficiency in working integer, real, and logical vectors in R."
---

<!-- 
### SO IMPORTANT ######################################################
To create a new tutorial, use:

usethis::use_tutorial(
   "<FileName>", 
   "<tutorialName>", 
   open = interactive())
#######################################################################
-->

```{r setup, include=FALSE}
library(learnr)
knitr::opts_chunk$set(echo = FALSE)
gradethis::gradethis_setup()
options(tutorial.event_recorder = tutorialize::recorder)
options(tutorial.storage = learnr::filesystem_storage(file.path(path.expand("~"), "_learnr_storage_")))

```

```{r prepare_die}
roll_die <- function(n, sides = 6) {
  side_values <- 1:sides
  rolls <- sample(side_values, n, replace = TRUE)
  return(rolls)
}
```

```{r prepare_two_dice}
roll_two_dice <- function(n, sides = c(6,6)) {
  if(length(sides) != 2 || !is.numeric(sides)) 
    stop("`sides` must be a numeric vector of length 2.")
  if(length(n) != 1 || !is.numeric(n)) 
    stop("`n` must be a numeric vector of length 1.")
  colSums(
    do.call(
      rbind,
      lapply(
        lapply(sides, \(to) 1:to),
        sample,
        size = n,
        replace = TRUE
      )
    )
  )
}

pretty_breaks <- function(x) {
  break_range <- range(x) + c(-0.5, 0.5)
  breaks <- seq(break_range[1], break_range[2], 1)
}

die1 <- rep(1:6, 6)
die2 <- rep(1:6, each = 6)
dice_values <- die1 + die2
```


## Probability and dice

Many common games involve rolling one or more six-sided dice.  We could simulate the roll of a six-sided die by randomly choosing a value from the vector `c(1,2,3,4,5,6)`.

In R, the `sample()` function draws random values from a vector.  For instance, I can draw three values from the vector `1:6` like so:

```{r, echo=TRUE}
sample(1:6, size = 3)
```

In the gaming world, some dice have 4 sides.  Other have 6, 8, 10, 12, or even 20 sides!  

![Dice with different numbers of sides](https://cdn.britannica.com/s:700x500/32/145832-004-510D6F21/types-dice.jpg){#id .class width=40% height=40%}

<br/>

In this R lab, we will explore the difference between the random numbers generated by rolling one 12-sided die vs. the numbers generated by summing a roll of two six-sided dice.  

We will accomplish this task by writing functions in R that simulate rolls of the dice, using the functions to simulate many rolls of the dice, and then exploring the frequency distributions of the values resulting from the simulated rolls.

<!-- We will also see how the shape is affected by rolling dice other than the standard 6-sided dice that are most common in U.S. culture. -->

<!-- To start, please use the internet to determine which R function will allow you to draw a random sample from a vector (e.g., allow you to simulate rolling a die). -->

<!-- ```{r sample_quiz} -->
<!-- quiz( -->
<!--   question("Based on your internet search, what R function will draw numbers at random from a vector of values?", -->
<!--     answer("random()"), -->
<!--     answer("roll()"), -->
<!--     answer("sample()", correct = TRUE), -->
<!--     answer("randomize()") -->
<!--   ) -->
<!-- ) -->
<!-- ``` -->

## Cast a die

Use the `sample()` function to simulate rolling a die.  Enter `?sample` in the console to read more about the `sample()` function.

- Create a vector of integers from 1 to 6 with the `:` operator; assign that vector to the name `six_sided`
- display the values contained in `six_sided` to be sure they are what you expect.
- Use the `sample()` function and draw one sample from `six_sided`; assign the result to the name `single_roll`
- Display the value of `single_roll`
- Run the code multiple times.  How many rolls will it take you to get a 1?  How about a 6?


```{r cast_a_die, exercise=tutorialize}
six_sided <- 1:6
six_sided
single_roll <- sample(six_sided, 1)
single_roll
```

## Make a histogram

A histogram is a "frequency plot" -- a bar graph with values on the x axis and the frequency of each value on the y axis. Here is a histogram of data (generated using the `hist()` function in R) that approximate a normal distribution

```{r}
hist(rnorm(10000), main = NULL, xlab = "Value", freq = F)
```

<!-- Use the internet to find a function to create a histogram in R.  -->

<!-- HINT: there are lots of "packages" (add-in libraries of addition functions for R) that make graphs in R, so finding a graphing function in R's built-in library can be a challenge.  Any time you want to find a function that is included in R's built-in libraries, include the phrase "base R" as part of your internet query. -->

<!-- ### What did you find?  -->

<!-- ```{r histogram_quiz} -->
<!-- quiz( -->
<!--   question("What base R function will create a histogram?", -->
<!--     answer("histogram()"), -->
<!--     answer("hist()", correct = TRUE), -->
<!--     answer("frequency()"), -->
<!--     answer("distribution()") -->
<!--   ) -->
<!-- ) -->
<!-- ``` -->

Try making this histogram yourself, using `rnorm(n)` (which generates a vector of `n` random numbers drawn from a normal distribution) and `hist()` (which draws a histogram from any vector of numbers.  

- Use `rnorm(n)` to generate `n = 10000` random draws from a normal distribution; assign the result to `normal_draw`.
- Pass `normal_draw` to `hist()` to create the histogram.

```{r basic_histogram, exercise=tutorialize}
normal_draw <- rnorm(10000)
hist(normal_draw)
```


## PD for 1 die

A histogram of values resulting from a series of random events is a special histogram called a "probability distribution" (PD).  If you sample events randomly (e.g., roll a die multiple times and make a record of each number), the resulting histogram will be an *estimate* of the shape of the underlying (actual) PD.  The more times you roll the die, the more accurate your estimate of the PD will become.

### Roll baby, roll!

Let's use the `sample()` function to simulate rolling a die 50 times! Then, we can make a histogram of the result and have a sense of the shape of the PD associated with rolling one die.  In this case, we'll roll a 12-sided die. 

- Create a vector representing a twelved-sided die and assign it to the name `twelve_sided`.
- Draw 50 samples from `twelve_sided` and assign the result to the name `many_rolls`.
- Make a histogram by passing only `many_rolls` to the `hist()` function.  
- Run your code several times to see what happens to the estimate of the PD each time you roll 50 dice.

HINT: If you are getting an unexpected error, you might need to enter `?sample` in the console and read about the `replace` parameter.  (Then again, it could also be something else...)

```{r roll_the_dice_50, exercise=tutorialize}
# Solution...
twelve_sided <- 1:12
many_rolls <- sample(
  twelve_sided, 
  50, 
  replace = TRUE)
hist(many_rolls)
```

### An improved histogram

You may have noticed the x-axis on the PD is a little off.  More than one value is grouped together in a single cell ("bar") on the graph.  We can plot each value in its own cell using the `breaks` parameter of `hist()`.

Type `?hist` in the console and read about the `breaks` parameter.

We're going to use the first option -- passing in a vector of break points.  

In order to center the histogram cells above each number on the x axis, the `breaks` (left and right edges of the cells) must be half way between the whole-number values on the x axis.  So, for the values `1:12`, the breaks would be `c(0.5, 1.5, 2.5, ..., 11.5, 12.5)`

In the sandbox below...

- Copy your code from the prior exercise and paste it below.
- Use `seq()` to create this sequence of break values described above and pass that sequence to the appropriate `breaks` parameter in `hist()`.

```{r roll_the_dice_50_breaks, exercise=tutorialize}
twelve_sided <- 1:12
many_rolls <- sample(
  twelve_sided, 
  50, 
  replace = TRUE)
hist(
  many_rolls, 
  breaks = seq(0.5, 12.5, 1))

```


### Roll *a lot*!

- Copy your code from the prior exercise and paste it below.  
- Modify your code so that it simulates rolling the dice 100,000 times!
- Run the code a few times to see how the histogram responds with each new set of 100,000 rolls.

```{r roll_the_dice_10000, exercise=tutorialize}
twelve_sided <- 1:12
many_rolls <- sample(
  twelve_sided, 
  100000, 
  replace = TRUE)
hist(
  many_rolls, 
  breaks = seq(0.5, 12.5, 1))
```

### What changed?

Did you notice the difference in the estimate of the PD between 50 roles of the dice and 100,000 roles of the dice? The estimate was a lot more stable with more role, wasn't it?  

So, you've demonstrated -- with only novice programming skills -- the effect of sample size on the quality of the estimat of the PD.  

Nice work!

<!-- The exercises above asked you to roll 50 dice several times and observe how the estimates of the PD changed.  Then you were asked to roll 100,000 dice several times and see how the estimated PDs changed.  What did you notice? -->

```{r histogram_behavior}
quiz(
  # question_text(
  #   "How did the behavior of the estimated probablity distribution change when you rolled more dice?  How do you explain the change?",
  #   answer_fn(TA),
  #   correct = "Thanks. The TA will evaluate your answer.  A correct answer would be something like 'When more dice are rolled, the estimated probability distribution becomes more stable because larger sample sizes are more representative of the true underying distribution.'"
  # ),
  question("Which distribution describes the shape of the probablity distribution resulting from rolling a die?",
    answer("normal distribution"),
    answer("uniform distribution", correct = TRUE),
    answer("there is no structure to the distribution")
  )
)
```

## Custom functions

R provides thousands of functions that we use to perform many different tasks. Sometimes, though, we might want to create a function that performs a task of our own choosing.

### Create a function with the Pythagorean theorum

Let's say we want to create a function that calculates the length of the longest side `c` (the "hypotenuse") of a right triangle given the length of the other two sides ("legs") `a` and `b`.  

The Pythagorean theorem states:

$$
c = \sqrt{a^2 + b^2}
$$

So we can create a function that accepts the parameters `a` and `b`.  We can put code inside the function to calculate `c` from any values of `a` and `b` that a user passes to the function.  Then we can specify that `c` is the value returned by the function.  

We can assign that function to any name we like, but descriptive names make our code more readable.  In this case, we'll assign the function to the name `hypotenuse`.

The function just described has been created for you below. The code between `{` and `}` is code that is executed when you call the function.  However, note that the calculations inside the function (between `{` and `}`) are *not quite* correct.  

- Find and fix the error in the code...
- Then modify the last line to calculate the hypotenuse of a triangle where leg `a` is 3 units (inches, cm, m, or whatever) and leg `b` is 4 units.

Also, take a little time to consider `function(a, b)` in the first line.  Notice how the parameters required by the new function are defined simply by including their names in the parenthesis after `function()`.

```{r hypotenuse, exercise=tutorialize}
#+ hypotenuse <- function(a, b) {
#+   c <- sqrt(a^3 + b^3)
#+  return(c)
#+ }
#+
#+ hypotenuse(a = ____, b = ____)
hypotenuse <- function(a, b) {
  c <- sqrt(a^2 + b^2)
  return(c)
}

hypotenuse(a = 3, b = 4)
```

### A simple roll of the dice

It would be simpler to simulate rolling a die if we had a function we could call to perform the simulation.  So let's create a function called `roll_die()` that can simulate 1 or more rolls of a die of any number of sides!

The function `roll_die()` should accept two parameters -- `n` (the number of rolls to simulate) and `sides` (the number of sides on the die).  The default value of `sides` should be `6`. (Notice in the code below how to define the default value of `6` when you define the parameters for the function.)

The following code is a start.  Follow the bullet points below to fill in the body of the function (between `{` and `}`).  Then, run the last line of the code in the box below to see if the function produces the expected results.

Within the function:

- Create a vector representing the possible values for a die with `sides` sides and assign the vector to the name `side_values`.
- Generate `n` random draws from `side_values`.
- assigns the value to the name `rolls`
- return the value in `rolls`.

```{r roll_die, exercise=tutorialize}
#+ roll_die <- function(n, sides = 6) {
#+   
#+ }
#+ 
#+ # test your function with this line of code
#+ roll_die(n = 5)
roll_die <- function(n, sides = 6) {
  side_values <- 1:sides
  rolls <- sample(side_values, n, replace = TRUE)
  return(rolls)
}

# test your function with this lines of code.  Do you get 20 values that are between 1 and 6?
roll_die(n = 20)
```


### Roll a 20-sided die

Now use `roll_die` to roll a 20-sided die 15 times.

```{r twenty_sided, exercise=tutorialize, exercise.setup=roll_die}
roll_die(n = 15, sides = 20)
```

### Rolling a pair of dice

Now lets create a function called `roll_two_dice()` that rolls two dice at the same time and sums the result.

The function will again accept two parameters -- `n` and `sides`.  This time, however, `sides` will accept a vector of length 2 -- the first value in the vector is the number of sides on the first die, and the second value in the vector is the number of dice on the second die!  

Notice in the code below that you will have to define the parameters and default values within `function()`.

The function should:

- Have a default value of `c(6,6)` for `sides` (indicating that the function will roll two 6-sided dice by default).
- Sum the results of two calls to `roll_die()`.  The first call should be with `sides = sides[1]` and the second call with `sides = sides[2]`. (In your code, try summing these results of the `roll_dice()` functions directly, rather than assigning the results to names and using the names in the sum).  
- Assign the summed results to the name `rolls`
- return the value in `rolls`.

Then, test your function by running the last line of code (below) several times.

```{r roll_two_dice, exercise=tutorialize, exercise.setup=roll_die}
#+ roll_two_dice <- function(____) {
#+   
#+ }
#+
#+ # test your function with these lines of code
#+ roll_two_dice(n = 10)
roll_two_dice <- function(n, sides = c(6,6)) {
  rolls <- roll_die(n, sides[1]) + roll_die(n, sides[2])
  return(rolls)
}

# test your function with these lines of code
roll_two_dice(n = 10)
```


## PD for two dice

In a moment, we're going to roll two dice several of times and look at the estimate of the probability distribution.

But before we do, let's think for a second.  To make a nice histogram, we have to calculate the `breaks` between the cells of the histogram.  

For a 6-sided die, the breaks are `c(0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5)`

For a 20-sided die, the breaks are `c(0.5, 1.5, 2.5, ... , 19.5, 20.5)`

For *two* 6-sided dice, the lowest roll is 2 and the highest is 12, so the breaks are `c(1.5, 2.5, 3.5, ... , 11.5, 12.5)`

This could get tedious!  Wouldn't it be nice to have a function that can calculate the breaks this for us?  Well... let's write one!

### Calculate histogram breaks

If you think about the examples above, there is a formula for calculating the breaks:

- Find the range of the rolls (the lowest and highest values).
- Subtract 0.5 from the lowest value and add 0.5 to the highest value.
- Make a sequence between the resulting values with an interval of one.

OK, then!  That's not too hard!  I've started you off with some code, below.  In the code:  

- Note that `range(x)` returns a vector of length 2 containing the lowest and highest values found in `x`.  In other words, `range(1:6)` will return the equivalent of `c(1,6)`.
- Fill in the blanks in the `seq()` function and run the code.  Look carefully at the output.  Is it right?
- If not, think about what kind of error in the code might cause the output you get.
- Find and fix any errors until the the function returns the correct breaks for both cases (the last two lines provided at the bottom of the code).

```{r breaks_function, exercise=tutorialize, exercise.setup=roll_two_dice}
#+ pretty_breaks <- function(x) {
#+  # Notice how I implemented the subtraction and addition to 
#+  # the range! I used vector arithmetic to add a negative 
#+  # and a positive value to the result from `range(x)`
#+  break_range <- range(x) + c(0.5, -0.5)
#+  breaks <- seq(____, ____, ____)
#+  return(breaks)
#+}
#+
#+ # test your function with these lines of code
#+ pretty_breaks(1:6)
#+ pretty_breaks(2:12)
pretty_breaks <- function(x) {
  # Notice how I implemented the subtraction and addition to 
  # the range! I used vector arithmetic to add a negative 
  # and a positive value to the result from `range(x)`
  break_range <- range(x) + c(-0.5, 0.5)
  breaks <- seq(break_range[1], break_range[2], 1)
  return(breaks)
}

# test your function with these lines of code
pretty_breaks(1:6)
pretty_breaks(2:12)
```

### Two dice, a few rolls

Now that we can easily generate the `breaks` to make lovely histograms, lets look that some probability distributions!  We'll start with the PD for rolling two six-sided dice.

- Use `roll_two_dice()` to simulate rolling a pair of six-sided dice 50 times; assign the result to the name `rolls`. 
- Make a histogram of `rolls`; use `breaks = pretty_breaks(rolls)` when you call the `hist()` function
- Run your code several times before submitting it and see what happens to your estimate of the PD for rolling two dice.

```{r hist_of_two_dice_50, exercise=tutorialize, exercise.setup=breaks_function}
rolls <- roll_two_dice(50)
hist(rolls, breaks = pretty_breaks(rolls))
```

### Two dice, LOTS of rolls!

Copy all of your code from the prior exercise and paste it below.  Change the code so that it rolls a pair of dice 100,000 times.  

Run the code a few times and see how the estimate of the PD changes for every set of 100,000 rolls of the dice.

```{r hist_of_two_dice_100K, exercise=tutorialize, exercise.setup=breaks_function}
rolls <- roll_two_dice(100000)
hist(rolls, breaks = pretty_breaks(rolls))
```


```{r prob_dist_pair_of_dice_quiz}
quiz(
  question("The shape of the probability distribution associated with rolling a pair of dice is closest to which of the following?",
    answer("normal distribution", correct = TRUE),
    answer("uniform distribution"),
    answer("there's no structure to the distribution")
  )
)
```

## Permutations

Here is a summary of what we've found, then.  When we roll one twelve-sided die, the probability distribution looks like this:

```{r}
hist(rep(1:12, 10), breaks = seq(0.5, 12.5, 1), main = NULL, xlab = "Value")
```

When we roll two six-sided dice, the probability distribution looks like this:

```{r}
hist(rep(1:6 + rep(1:6, each = 6), 5), breaks = seq(0.5, 12.5, 1), main = NULL, xlab = "Value")
```

So why does the PD change from a uniform PD when we roll one die to something more like a normal PD when we roll two dice?

Well, let's think about this.  If we roll one die, then there is an equal probability of rolling each number.  So the probability distribution is flat (equal for each number on the die).  That make sense.

But what should be expect for two dice?  Well, there should be an equal probability of encountering each permutation (ordered combination) of values on the two dice. Let's figure out the permutations.  

We have two dice: `die1` and `die2`.  If we assume `die2` is showing `1`, then there are six possible states for `die1`, namely `c(1,2,3,4,5,6)`.  If we assume `die2` is showing `2`, then there are again six possible states for `die1`.  And so on.

Therefore, we can represent all of the possible permutations of `die1` and `die2` with two vectors, like so:

```{r}
matrix(
  c(
    rep(1:6, 6),
    rep(1:6, each = 6)),
  ncol = 2,
  dimnames = list(NULL, c("die1", "die2")))
```

Not surprisingly, there are 6 x 6 = 36 permutations for two six sided dice.  Notice the pattern of the two vectors, however, for `die1` and `die2`.  The `die1` vector repeats the entire vector `1:6` six times.  The `die2` vector repeats *each* value in `1:6` six times before moving on to the next value.

Let's see if we can recreate these two vectors in R.  We can then sum the two vectors to find the total dice score we would expect for each of these permutations!

### This is a job for `rep()`!

Any time you want to repeat values in a vector, you should immediately think of the `rep()` function.  Use `?rep` in the console to read about the rep function.  Pay special attention to the `each` parameter.

In the sandbox below, use `rep()` to:

- Create a vector containing the sequence `1:6` repeated six times; assign the vector to `die1`
- Display `die1`
- Create a vector containing *each value* in `1:6` repeated six times, followed by the next value; assign the vector to `die2`
- Display `die2`

```{r permutations, exercise=tutorialize, exercise.setup=breaks_function}
die1 <- rep(1:6, 6)
die1
die2 <- rep(1:6, each = 6)
die2
```


Now that we have the values from `die1` and `die2` in two vectors, we can get the value of each permutation of dice by using vector arithmetic.

- Add `die1` and `die2` together to get the summed value for each permutation of the dice; assign the result to `dice_values`
- Display `dice_values`

```{r sum_the_permutations, exercise=tutorialize, exercise.setup=permutations}
dice_values <- die1 + die2
dice_values
```

Look at dice values.  What you notice about the frequency of different numbers?  It might be easier to see if we sort the numbers

- Pass `dice_values` to the `sort()` function

```{r sort_permutations, exercise=tutorialize, exercise.setup = sum_the_permutations}
sort(dice_values)
```

Huh.  There are lots of 7's, but only one 2 and one 12.  This means that lots of different permutations result in 7, but there is only one permutation that results in 2 and one that result in 12.

That makes sense!  All of the following permutations yield 7:  1+6, 2+5, 3+4, 4+3, 5+2, and 6+1.  The only way to get 2 is 1+1.  The only way to get 12 is 6+6.

Finally, make a histogram of `dice_values`

- Pass `dice_values` to the `hist()` function.
- Be sure to include `breaks = pretty_breaks(dice_values)` to set the break points!

```{r hist_permutations, exercise=tutorialize, exercise.setup = sum_the_permutations}
hist(
  dice_values,
  breaks = pretty_breaks(dice_values))
```

Does the graph look familiar?  

Huh.  Apparently, the underlying probability distribution for rolling dice is the distribution of total scores that arise from the different permutations of the dice!  That's cool.  Sort makes sense, doesn't it?

### Let's check and see if we are right.

The rest of your lab that will be graded.  There are no solutions to look at, but you can go back to your prior answers to get help!

Let's simulate 100000 rolls of a 4-sided die and a 10-sided die.

- Use `roll_two_dice()` to perform the simulation.
- Create a histogram of `rolls`; don't forget to make the breaks pretty!

```{r hist_4_10_permutations, exercise=TRUE, exercise.setup = "hist_of_two_dice_50-setup"}

```

```{r hist_4_10_permutations-solution, exercise.reveal_solution=FALSE}
rolls <- roll_two_dice(100000, c(4,10))
hist(rolls, pretty_breaks(rolls))
```


```{r hist_4_10_permutations-check}
grade_this( {
  pass_if(
    TRUE, 
    message = "Your solution has been submitted for grading.") })
```

Now, use `rep()` to calculate the permutations and plot a histogram of the results.  Here's what the permutation vectors look like:

```{r}
matrix(
  c(
    rep(1:4, 10),
    rep(1:10, each = 4)),
  ncol = 2,
  dimnames = list(NULL, c("die1", "die2")))
```

Using the table above as a guide, calculate the permutation vectors for the `die1` and `die2`, sum them, then make a histogram of the results (with pretty breaks, of course!)

```{r hist_4_10_PD, exercise=TRUE, exercise.setup = "hist_of_two_dice_50-setup"}

```

```{r hist_4_10_PD-solution, exercise.reveal_solution=FALSE}
dice_values <- rep(1:4, 10) + rep(1:10, each = 4)
hist(dice_values, pretty_breaks(dice_values))
```


```{r hist_4_10_PD-check}
grade_this( {
  pass_if(
    TRUE, 
    message = "Your solution has been submitted for grading.") })
```

### Right on!

Nice work.  You are done with Lab 3!  Be sure to turn it in using `ENSC311::submit_ENSC311()`
